title: 从数组去重来看 javascript 的进化
date: 2017-04-07 09:44:00
categories: 技术研究
tags: [javascript]
---
[kk-player 17538867]
[00:10.640]Semper crescis
[00:12.780]Aut decrescis
[00:15.080]Vita detestabilis
[00:18.370]Nunc obdurat
[00:20.410]Et tunc curat
[00:22.670]Ludo mentis aciem
[00:33.720]Nunc obdurat
[00:35.760]Et tunc curat
[00:37.990]Ludo mentis aciem
[00:41.270]Egestatem
[00:43.400]Potestatem
[00:45.630]Dissolvit ut glaciem
[00:49.630]Divano
[00:51.530]Divano me
[00:53.740]Divano messi
[00:55.880]Divano messia
[00:59.200]Divano messia
[01:02.690]Divano
[01:04.580]Divano me
[01:06.840]Divano messia
[01:09.010]Divano messia
[01:21.660]Sors salutis
[01:23.820]Et virtutis
[01:26.030]Michi nunc contraria
[01:29.340]Est affectus
[01:31.400]Et defectus
[01:33.550]Semper in angaria
[01:37.030]Hac in hora
[01:39.010]Sine mora
[01:41.360]Corde pulsum tangite
[01:45.910]Divano
[01:47.820]Divano me
[01:50.000]Divano messi
[01:52.330]Divano messia
[01:55.510]Divano messia
[01:59.070]Divano
[02:00.970]Divano me
[02:03.220]Divano messia
[02:05.340]Divano messia
[02:11.880]Divano
[02:13.880]Divano me
[02:15.990]Divano messia
[02:18.130]Divano messia
[02:25.460]In divanooooo
[02:31.290]Sors salutis
[02:33.430]Et virtutis
[02:35.670]Michi nunc contraria
[02:38.970]Est affectus
[02:41.030]Et defectus
[02:43.220]Semper in angaria
[02:46.620]Hac in hora
[02:48.740]Sine mora
[02:50.980]Corde pulsum tangite
[02:55.570]Divano
[02:57.540]Divano me
[02:59.690]Divano messi
[03:02.990]Divano messia
[03:06.080]Divano messia
[03:09.590]Divano
[03:11.590]Divano me
[03:13.730]Divano messia
[03:15.910]Divano messia
[03:20.370]Hac in hora
[03:22.400]Sine mora
[03:24.720]Corde pulsum tangite
[03:28.020]Quod per sortem
[03:30.120]Sternit fortem
[03:32.350]Mecum omnes plangite
[/kk-player]<br />
说到 javascript 数据去重，估计所有做前端的都并不陌生
数组去重的算法即使在实际生产中不一定用的多，但是在面试中几乎成为了必考的题目<br />
这是一个神奇的题目，看上去好像是死的，应该已经没有什么发挥空间了<br />
但事实上它随着 ECMAScript 标准的发展，数据去重的实现反倒是在不断变化<br />
许多公司甚至可以单从一个数组去重直接看出一个前端工程师的大致水平<br />
今天我也来说说我所知道的 javascript 数组去重吧<br />
<!--more--><br />
<span style="font-size:18px;">一、最传统的实现方式</span> 
<pre class="brush:js; toolbar:false;">var array = [1, 0, 1, NaN, '1', '', true, false, true];
var result = [];
var i, j;
var flag;
for (i = 0; i &lt; array.length; i++) {
  flag = true;
  for (j = 0; j &lt; result.length; j++) {
    if (array[i] === result[j]) {
      flag = false;
      break;
    }
  }
  if (flag) {
    result.push(array[i]);
  }
}
console.log(result);
// 输出结果：[1, 0, NaN, "1", "", true, false]
</pre>
<br />
这种写法在 ECMAScript 3 的标准（也就是ECMA-262 第3版）下，还可以稍微缩写一下<br />
<pre class="brush:js; toolbar:false;">var array = [1, 0, 1, NaN, '1', '', true, false, true];
Array.prototype.uniq = function() {
  var result = [];
  for (var i = 0; i &lt; this.length; i++) {
    if (result.indexOf(this[i]) === -1) {
      result.push(this[i]);
    }
  }
  return result;
}
console.log(array.uniq());
// 输出结果：[1, 0, NaN, "1", "", true, false]
</pre>
<br />
<span>这就是我所说的最传统的方式，几乎所有学过编程的都能想得到，逻辑简单粗暴，而且大多数情况下都管用<br />
<br />
<span style="font-size:18px;">二、借助 javascript 对象的特性来构造 hash 表实现去重</span></span><br />
上面最传统的写法，我说大多数情况下管用，没有说绝对好用，事实上是因为它确实有缺陷<br />
比如当数组中存在多个 NaN 时：
<pre class="brush:js; toolbar:false;">var array = [1, 0, 1, NaN, '1', '', true, false, true, NaN];</pre>
<br />
上面的第一种方法就会返回以下结果：<br />
<pre class="brush:js; toolbar:false;">[1, 0, NaN, "1", "", true, false, NaN]</pre>
<br />
可见，第一种方法无法去掉 NaN 的重复，所以后来有人就想到了第二种方法<br />
借助 javascript 对象天然的 hash 特性来去除数组中重复的值<br />
<pre class="brush:js; toolbar:false;">var array = [1, 0, 1, NaN, '1', '', true, false, true, NaN];
Array.prototype.uniq = function() {
  var result = [], map = {};
  for (var i = 0; i &lt; this.length; i++) {
    map[this[i]] = this[i];
  }
  for (var key in map) {
    result.push(map[key]);
  }
  return result;
}
console.log(array.uniq());
// 输出结果 [0, "1", NaN, "", true, false]</pre>
<br />
去重成功，说明这种方法是可行的，而且这样子去重的速度比前面第一种方式要快得多，因为只有一层循环，所以时间复杂度为O(n)<br />
相比前面的两层循环（时间复杂度为<span>Ο(<em>n</em><sup>2</sup>)</span>），确实有了质的提升。<br />
不过输出结果似乎跟前面相比，除了NaN去掉了之外，数字1和字符串1也被当成重复的给去掉了<br />
所以使用这种方法去重的时候，需要注意这种方法跟前面的去重方式相比，有一种本质性的不同<br />
前面的去重是用三个等号判断的，也就是强类型去重，而这种使用hash表的去重方法，其实是借助转换成字符串的方式去重<br />
这种借助hash表中的key（字符串类型）的去重方式，不属于强类型去重，也不属于弱类型去重（因为NaN == NaN不成立），它应该属于一种独特的去重方式<br />
往往我们对这种去重方式还是不满意，因为它把数字1和字符串1也给合并了，我们可以稍微修改一下，在key里面同时加上类型：<br />
<pre class="brush:js; toolbar:false;">var array = [1, 0, 1, NaN, '1', '', true, false, true, NaN];
Array.prototype.uniq = function() {
  var result = [], map = {};
  for (var i = 0; i &lt; this.length; i++) {
    map[typeof this[i] + this[i]] = this[i];
  }
  for (var key in map) {
    result.push(map[key]);
  }
  return result;
}
console.log(array.uniq());
// 输出结果 [1, 0, NaN, "1", "", true, false]</pre>
<br />
这样子基本上就算是实现了我们预期的目标了，同时支持了去除NaN的功能<br />
<br />
<span style="font-size:18px;">三、借助 ECMAScript 5 的新特性进行简写</span><br />
上面的写法在发展到ES5以后有了更简便的写法，可以借助过滤<span>函数</span>filter进行优化：<br />
<pre class="brush:js; toolbar:false;">var array = [1, 0, 1, NaN, '1', '', true, false, true, NaN];
Array.prototype.uniq = function() {
  var map = {};
  return this.filter(function(item) {
    var key = typeof item + item;
    return map.hasOwnProperty(key) ? false : (map[key] = true);
  })
}
console.log(array.uniq());
// 输出结果 [1, 0, NaN, "1", "", true, false]</pre>
<br />
<span style="font-size:18px;">四、借助 ECMAScript 6 的新特性进行简写</span><br />
到了ES6还有更简便的写法，第一种是借助Map对象和箭头函数语法糖：<br />
<pre class="brush:js; toolbar:false;">var array = [1, 0, 1, NaN, '1', '', true, false, true, NaN];
Array.prototype.uniq = function() {
  const seen = new Map();
  return this.filter(a =&gt; !seen.has(a) &amp;&amp; seen.set(a, true))
}
console.log(array.uniq());
// 输出结果 [1, 0, NaN, "1", "", true, false]</pre>
<br />
第二种是直接借助Set：<br />
<pre class="brush:js; toolbar:false;">var array = [1, 0, 1, NaN, '1', '', true, false, true, NaN];
Array.prototype.uniq = function() {
  return Array.from(new Set(this));
}
console.log(array.uniq());
// 输出结果 [1, 0, NaN, "1", "", true, false]</pre>
<br />
可见，发展到ES6之后，已经可以一行就实现数组去重了<br />
不由得感叹一下，标准的发展使得生产真是越来越便利了！<br />
<br />
<span style="font-size:24px;">参考资料：</span><br />
<a href="http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array" target="_blank">Remove Duplicates from JavaScript Array</a><br />
<a href="https://www.zhihu.com/question/29558082" target="_blank">求一个javascript数组去重方法？</a><br />
<a href="https://www.toobug.net/article/array_unique_in_javascript.html" target="_blank">也谈JavaScript数组去重</a><br />
<a href="https://github.com/hanzichi/underscore-analysis/issues/9" target="_blank">JavaScript 数组去重</a><br />